appraoch-1 using binary search 
T.C-o(N * LogN)
class Solution {
public:
    bool isPossible(int maxl,vector<int>& presum,int target){
        
         int j =0;
         int n = presum.size();
         int sum =0;
         while(j+maxl-1<n){
            

            sum = presum[maxl+j-1] - (j>0 ? presum[j-1] : 0);

            if(sum>=target)
             return true;

             j++;  
         }

    return false;   
    }

    int minSubArrayLen(int target, vector<int>& nums) {
          int n = nums.size();
          vector<int>presum(n);

          presum[0] = nums[0];

          for(int i=1;i<n;i++){
            presum[i] = presum[i-1] + nums[i];
          }
     
        int l =1;
        int r = n; // size of maximum subarray

        int result =0;

        while(l<=r){
            int mid = (l+r)/2;

            if(isPossible(mid,presum,target)){
                result = mid;
                r = mid-1; // minimize the answer
            }
            else
             l = mid + 1;
        }
    return result;    
    }
};
approach-2 using sliding window
T.C - O(N)
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {

        int n = nums.size();
        
        int j =0,i=0;
        int minL = INT_MAX;
        int sum =0;
        while(j<n){
            sum+= nums[j];

            while(sum>=target){
                minL = min(minL,j-i+1);

                sum -= nums[i];
                i++;
            }
            j++;
        }
    return minL ==INT_MAX ? 0 : minL ;    
        
    }
};


