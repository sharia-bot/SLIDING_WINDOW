class Solution {
public:
    long long sum = 0;
    set<pair<int,int>>main;
    set<pair<int,int>>sec;
    void InsertInset(pair<int,int>p , int x){
        if(main.size() < x || p>*main.begin()){
            sum+= 1LL* p.first*p.second; // alawys update sum when insert in main
            main.insert(p);

           if(main.size()>x) {
              auto smallest = *main.begin(); // remove from begin of the main set
              sum-= 1LL * smallest.first*smallest.second; // update the sum
              main.erase(smallest);
              sec.insert(smallest);
           }
        }
        else
         sec.insert(p);
    }
    void removeFromset(pair<int,int>p){
        if(main.find(p)!=main.end()){
            sum-= 1LL* p.first*p.second;
            main.erase(p);

            if(!sec.empty()){
                auto largest = *sec.rbegin();
                sum += 1LL * largest.first* largest.second;
                main.insert(largest);
                sec.erase(largest);
            }
        }
        else
        sec.erase(p);
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {

        int  n = nums.size();
        unordered_map<int,int>mp;
        vector<long long > result;

        int i =0;
        int j =0;

        while(j<n){
            if(mp[nums[j]]>0){
                removeFromset({mp[nums[j]],nums[j]});
            }
            
                mp[nums[j]]++;
                InsertInset({mp[nums[j]],nums[j]},x);
            
            if(j-i+1==k){
                result.push_back(sum);
                // now srinking the window
                removeFromset({mp[nums[i]],nums[i]});
                mp[nums[i]]--;
                if(mp[nums[i]]==0){
                    mp.erase(nums[i]);
                }
                else{
                    InsertInset({mp[nums[i]],nums[i]},x);
                }
                 
                i++;
            }
            j++;
        }
    return result;    
    }
};
